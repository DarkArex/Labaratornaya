# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил(а):
- Корявец Роман Иванович
- ЗПИЭ-20-2

| Задание | Сам_раб |
| ------  | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декоратор для функции, который будет выяснять за какое время выполняется та или иная функция. Помогите Вовочке в его начинаниях и напишите такой декоратор. Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы.

```python
import time

def timing_decorator(function):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = function(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения функции Фибоначи: {end_time - start_time} секунд")
        return result
    return wrapper

@timing_decorator
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
    print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/1.png)

## Выводы
В ходе работы я создал декоратор для измерения времени выполнения функции Фибоначчи. В ходе работы с кодом я узнал, как создать декоратор, который измеряет время выполнения функции и выводит результат в секундах. Ваша функция Фибоначчи генерирует числа Фибоначчи до 200-го элемента и выводит их в консоль.

## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считывать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете вводные данные для решения задачи. После этого вы решили не просто считывать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то, нужно вызвать исключение (“бросить исключение”) и вывести в консоль “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
with open('nonetext.txt.txt', 'w') as empty:
    pass
with open('textthistext.txt.txt', 'w') as full:
    full.write("Таки текста есть")
def Chek(doc):
    try:
        with open(doc, 'r') as file:
            text = file.read()
        if not text:
            raise Exception("Таки файл пустой")
        return text
    except Exception as e:
        print(f"Ошибка: {e}")
print("Содержимое пустого файла:")
nonetext = Chek('nonetext.txt.txt')
print("\nСодержимое файла с информацией:")
textthistext = Chek('textthistext.txt.txt')
if textthistext:
    print(textthistext)
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/2.png)
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/2.1.png)
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/2.2.png)
## Выводы
В ходе работы, я изучл возможности открытия и создания файлов. А также вызов функций и обработку исключений.
  
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выведется ошибка “Неподходящий тип данных. Ожидалось число.”. Реализовать функционал программы необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет листинг кода и получившийся вывод в консоль.

```python
def sum():
    try:
        x = input("Введите число: ")
        num = float(x)
        res = 2 + num
        print(f"Результат сложения: {res}")
    except ValueError:
        print("Ошибка: Неподходящий тип данных. Ожидалось число.")

sum()
sum()
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/3.png)

## Выводы
В ходе выполнения работы я создал функцию sum(), которая принимает ввод пользователя и пытается сложить введенное число с 2. Затем вызвает эту функцию дважды. Если введенное значение не может быть преобразовано в число, то будет выведено сообщение об ошибке.

## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для двух любых вами придуманных функций. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс декоратора, две как-то связанными с ним функциями, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python
import time
def Time(x):
    def cover(*args, **kwargs):
        start = time.time()
        res = x(*args, **kwargs)
        end = time.time()
        work = (end - start) * 1000
        print(f"Функция {x.__name__} выполнилась за {work:.2f} мс")
        return res
    return cover
@Time
def slow():
    time.sleep(2)
    print("Медленная функция")
@Time
def fast():
    time.sleep(0.3)
    print("Быстрая функция")
slow()
fast()
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/4.png)

## Выводы
В ходе работы мы изучили использование декораторов для измерения времени выполнения функций, что может быть полезно при оптимизации или оценке производительности кода.

## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет: класс исключения, код к котором в двух местах используется это исключение, скриншот консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.
### 

```python
class Erorr(Exception):
    def __init__(self, text):
        super().__init__(text)
def Proverka(x):
    if x < 0:
        raise Erorr("Значение не может быть отрицательным.")
    elif x == 0:
        raise Erorr("Значение не может быть равным нулю.")
    else:
        print("Значение допустимо.")

try:
    Proverka(-5)
except Erorr as e:
    print(f"Поймано исключение: {e}")
else:
    print("Программа успешно завершена.")

def Obrabotka(y):
    if not y:
        raise Erorr("Невозможно обработать пустые данные.")
    print("Данные обработаны.")

try:
    y = []  #
    Obrabotka(y)
except Erorr as e:
    print(f"Поймано исключение: {e}")
else:
    print("Программа успешно завершена.")
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-10/picture/5.png)

## Выводы
В ходе изучение материала мы зучили использование пользовательских исключений и их обработку в Python.
## Общие выводы по теме
Декораторы, как мы изучили, позволяют изменять поведение функций, методов или классов, не затрагивая их самих. Они предоставляют средство для расширения или модификации функциональности вызываемых объектов. Кроме того, исключения позволяют элегантно управлять программой в случае возникновения ошибок. Они обеспечивают удобный способ контролировать ход выполнения программы при неожиданных ситуациях. Мы также освоили создание собственных декораторов и исключений, что позволяет индивидуально адаптировать их под конкретные нужды проекта или задачи.
