# Тема 8. Введение в ООП
Отчет по Теме #8 выполнил:
- Корявец Роман Иванович
- ЗПИЭ-20-2

| Задание | Сам_раб |
| ------  | ------ |
| Задание 1 | + |
| Задание 2 | + |
| Задание 3 | + |
| Задание 4 | + |
| Задание 5 | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Plant:
    def __init__(self, name):
        self.name = name

Lil = Plant("Лилия")
print(f"Растение: {Lil.name}")
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-8/picture/1.png)

## Выводы
В ходе работы я создал создает класс "Plant" с одним атрибутом "name" и объект "Lil" этого класса с именем "Лилия". Затем вывел информацию о растении.

## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Plant:
    def __init__(self, name):
        self.name = name
        self.growth_stage = 1
    def grow(self):
        self.growth_stage += 1
    def describe(self):
        if self.growth_stage == 1:
            return f"{self.name} - это молодое растение"
        elif self.growth_stage == 2:
            return f"{self.name} - это зрелое растение"
        else:
            return f"{self.name} - это цветущее растение"
Lil = Plant("Лилия")
print(Lil.describe())
Lil.grow()
print(Lil.describe())
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-8/picture/2.png)

## Выводы
В ходе второй работы, я добавил атрибут "growth_stage" и методы "grow" и "describe". Метод "grow" увеличивает стадию роста растения, а метод "describe" выводит информацию о растении на основе его стадии роста.
  
## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Plant:
    def __init__(self, name):
        self._name = name
    def describe(self):
        return f"{self._name} - это растение"
class Flower(Plant):
    def __init__(self, name, color):
        super().__init__(name)
        self._color = color
    def describe(self):
        return f"{self._name} - это цветок с цветом {self._color}"
class Tree(Plant):
    def __init__(self, name, height):
        super().__init__(name)
        self._height = height
    def describe(self):
        return f"{self._name} - это дерево высотой {self._height} метров"
Lil = Flower("Лилия", "красный")
Tree = Tree("Дуб", 10)
Daisy = Flower("Ромашка", "белый")
plants = [Lil, Tree, Daisy]
for plant in plants:
    print(plant.describe())
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-8/picture/3.png)

## Выводы
В этой работе был создан класс "Flower", который наследует от класса "Plant". Класс "Flower" имеет дополнительный атрибут "color" и переопределенный метод "describe" для вывода информации о цветке, включая его цвет.
Теперь у меня получилась иерархия классов с наследованием, и класс "Flower" расширяет класс "Plant".

## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Plant:
    def __init__(self, name):
        self._name = name
        self._growth_stage = 1
    def grow(self):
        self._growth_stage += 1
    def describe(self):
        if self._growth_stage == 1:
            return f"{self._name} - это молодое растение"
        elif self._growth_stage == 2:
            return f"{self._name} - это зрелое растение"
        else:
            return f"{self._name} - это цветущее растение"
Lil = Plant("Лилия")
print(Lil._name)
print(Lil.describe())

```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-8/picture/4.png)

## Выводы
Изучив материал мы используем приватные атрибуты _name и _growth_stage с префиксом _. Это обеспечивает доступ к ним только внутри класса, но при желании пользователь может обойти инкапсуляцию и получить доступ к приватным атрибутам.

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Plant:
    def __init__(self, name):
        self._name = name
    def describe(self):
        return f"{self._name} - это растение"
class Flower(Plant):
    def __init__(self, name, color):
        super().__init__(name)
        self._color = color
    def describe(self):
        return f"{self._name} - это цветок с цветом {self._color}"
class Tree(Plant):
    def __init__(self, name, height):
        super().__init__(name)
        self._height = height
    def describe(self):
        return f"{self._name} - это дерево высотой {self._height} метров"
Lil = Flower("Лилия", "красный")
Tree = Tree("Дуб", 10)
Daisy = Flower("Ромашка", "белый")
plants = [Lil, Tree, Daisy]
for plant in plants:
    print(plant.describe())
```

### Результат
![Меню](https://github.com/DarkArex/Labaratornaya/blob/Tema-8/picture/5.png)

## Выводы
В этом коде мы создаем классы "Flower" и "Tree", оба наследуются от базового класса "Plant". Каждый из подклассов переопределяет метод "describe" собственным образом, чтобы предоставить информацию о себе.
Затем я создал несколько объектов разных классов и помещаем их в список. Используя полиморфизм, можно вызвать метод "describe" для каждого объекта в цикле, и он выполняется в соответствии с типом объекта, что позволяет вывести информацию о каждом растении в соответствии с его собственной логикой.


## Общие выводы по теме
В процессе изучения основ ООП были рассмотрены следующие ключевые концепции:
1) Классы: Классы представляют собой шаблоны или абстрактные описания объектов. Они определяют, какими свойствами и методами обладают объекты этого класса.
2) Объекты: Объекты представляют конкретные экземпляры классов. Они создаются на основе классов и имеют свои собственные значения свойств.
3) Наследование: Наследование позволяет создавать новые классы, наследуя свойства и методы от существующих классов. Это способ организации и обобщения кода.
4) Инкапсуляция: Инкапсуляция заключается в упаковке данных (полей) и методов, работающих с этими данными, внутри класса. Она скрывает детали реализации класса и обеспечивает контролируемый доступ к данным.
5) Полиморфизм: Полиморфизм позволяет использовать объекты разных классов с одинаковым интерфейсом (например, методами) как объекты одного и того же типа. Это способствует гибкости и упрощению кода.
6) Методы: Методы являются функциями, определенными внутри классов, и они представляют собой действия, которые объекты этого класса могут выполнять.
Эти концепции составляют основу объектно-ориентированного программирования (ООП) и позволяют создавать структурированный, гибкий и понятный код.

